.syntax meta;
.initialize
  "static void meta_exp1(void);\n"
  "static void meta_exp3(void);\n"
  "char *grammar_name;\n";
hex = .any('0','9')|.any('a','f')|.any('A','F');
xchar = '\\x' .token hex hex .deftoken;
xcharp = '\\x' {"'"%} hex .putc hex .putc {"'"};
arg = '$' {'emit_token(1);'}
    | '%' {'emit_token(0);'}
    | ('lf'|'nl') {"emit_char('\\n');"}
    | 'cr' {"emit_char('\\r');"}
    | .id {'emit('$');'}
    | xchar {"emit_char('\\x" $ "');"};
output = '{' *(.string {'emit('$');'} | arg) '}'
       | '<' *(.string {%} | arg) '>';
space_control = '\\' {'ignore_whitespace=true;'}
              | '/' {'ignore_whitespace=false;'};
user_token_delim = '.token' {'user_token=pos;'}
                 | '.deftoken' {'make_token(user_token);'}
                 | '.mute' {'mute=true;'}
                 | '.unmute' {'mute=false;'}
                 | '.capture' {'capture=calloc(1,1);'}
                 | '.defcapture' {'capture_to_token();'};
user_token_arg = .number {$}
               | xcharp
               | "'" \ {%} .any(32,126) .putc "'" / {%}
               | '"'\ "'" '"' / {"'\\''"};
user_tokens = '.any(' {'read_any_between('} user_token_arg ','{','} user_token_arg ')'{');'}
            | '.but(' {'read_any_but('} user_token_arg ','{','} user_token_arg ')'{');'}
            | '.eq(' {'read_char_eq('} user_token_arg ')'{');'}
            | '.neq(' {'read_char_neq('} user_token_arg ')'{');'}
            | '.putc' {'emit_char(source[pos-1]);'};
errors = '.error(' .string {'error('$');'} ')'
       | '.warn(' .string {'warning('$');'} ')'
       | '.expect(' .string {'expecting='$';unexpected=NULL;'} ')'
       | '.unexpect(' .string {'expecting=NULL;unexpected='$';'} ')'
       | '.noexpect' {'expecting=NULL;unexpected=NULL;'}
       | '.reason(' .string {'reason='$';'} ')'
       | '.noreason' {'reason=NULL;'}
       | '.failure' {'test_flag=false;exit_parse_rule();return;'}
       | '.success' {'test_flag=true;exit_parse_rule();return;'};
user_vars = '.bind(' .id {'char *'$'=token;token=NULL;'} ')'
          | '.var(' .id {'char *'$'=NULL;'} ')'
          | '.set(' .id {'if('$')free('$');'$'=token;token=NULL;'} ')'
          | '.concat(' .id {'concatstr('$',token);free(token);token=NULL;'} ')'
          | '.clear(' .id {'if('$'){free('$');'$'=NULL;}'} ')'
          | '.emit(' .id {'emit('$');'} ')'
          | '.ifte(' .id {'if('$')emit('$');else emit('} ',' .string {$');'} ')';
builtin_tokens = '.id' {'read_id();'}
               | '.number' {'read_number();'}
               | '.string' {'read_string();'}
               | '.space' {'skip_whitespace();'};
%optionals = '^' .capture exp3 .defcapture .bind(expA)
%            '^' .capture exp3 .defcapture .bind(expB)
%            {'do{bool expAdone=false,expBdone=false;'
%             'do{'expA'}while(0);expAdone=test_flag;'
%             'do{'expB'}while(0);expBdone=test_flag;'
%             'if(!expAdone)do{'expA'}while(0);'
%             'if(!expBdone)do{'expB'}while(0);'
%             '}while(0);test_flag=true;'};
option_capture = '^' .capture exp3 .defcapture;
multiple_optionals =
  <'char *opts_stack[2000];int last_opt=2;char idx[4];'>
  option_capture <'opts_stack[0]=token;token=NULL;'>
  option_capture <'opts_stack[1]=token;token=NULL;'>
  *( option_capture
     <'if(last_opt==2000-1){'> .error('excess of optionals') <'}'
      'opts_stack[last_opt++]=token;token=NULL;'> )
  <'sprintf(idx,"%d",last_opt);'>
  {'do{bool expr_results['idx'];'}
    <'for (int a=0; a<last_opt; a++){ sprintf(idx,"%d",a);'>
      {'do{'} <'emit(opts_stack[a]);'> {'}while(0);'
       'expr_results['idx']=test_flag;'}
    <'}'>
    <'for(int a=0;a<last_opt;a++){sprintf(idx,"%d",a);'>
      {'if(!expr_results['idx'])do{'}
        <'emit(opts_stack[a]);free(opts_stack[a]);'>
      {'}while(0);'}
    <'}'>
  {'}while(0);test_flag=true;'}
  ;
exp3 = .id {grammar_name'_'$'();'}
     | .string {'read_literal('$');'}
     | builtin_tokens
     | user_tokens
     | '(' exp1 ')'
     | '.e' {'test_flag=true;'}
     | '*' {'do{'} exp3 {'}while(test_flag);test_flag=true;'}
     | '!' {'do{'} exp3 {'}while(0);test_flag=!test_flag;'}
     | multiple_optionals;
dont_use_flag = user_token_delim
              | output
              | space_control
              | errors
              | user_vars;
exp2 = *dont_use_flag
       ( exp3 {'if(test_flag){'}
         *( dont_use_flag | exp3 {'error_if_false();'} )
         {'}'}
       | .e);
exp1 = 'continue' .success
     | {'do{'}
       .expect('a sequence of expressions') exp2
       *('|' {'if(test_flag)break;'} .expect('a sequence of expressions') exp2)
       {'}while(0);'};
stat = '%' *.neq(10)
     | .expect('a grammar rule identifier') .id
         {'static void 'grammar_name'_'$'(void)'
          '{enter_parse_rule("'$'");'}
       .expect('an equal sign') '='
       .expect('a sequence of expressions') exp1
       .expect('a ; terminator') ';'
       {'exit_parse_rule();}\n'};

initialize = '%' *.neq(10)
           | '.initialize'
             .expect('a sequence of code instructions (strings)') .string {%} *( .string {%} )
             .expect('a ; terminator') ';'
           | .e;

finalize = .expect('a compiler mode directive (.end,.multiple,.test,.finalize)')
           ( '.end'
             .expect('a grammar rule identifier') .id
             {'int main(int argc, char *argv[]){return first_into_second(argc,argv,'grammar_name'_'$');}\n'}
           | '.multiple'
             .expect('an file extension (string)') .string .bind(extension)
             .expect('a grammar rule identifier') .id
             {'int main(int argc, char *argv[]){ multiple_files(argc,argv,' extension ','grammar_name'_'$');return 0; }\n' }
           | '.test'
             .expect('a grammar rule identifier (optionally a maximum input size)') .id .bind(func_name)
             .var(max_input_size) (.number .set(max_input_size) | .e)
             {'int main (int argc, char *argv[]){return test('} .ifte(max_input_size,"4194304") {','grammar_name'_'func_name');}\n'}
           | '.finalize'
             .expect('a sequence of code instructions (strings)') .string <%> *(.string <%>) )
           .expect('a ; terminator') ';' ;
program = '.syntax'
            .expect('a grammar name') .space .id .set(grammar_name)
            .expect('a ; terminator')
            (.string {'#include "'%'/support.h"\n'} | .e {'#include "support.h"\n'}) ';'
          initialize
          *stat
          finalize;

.end program;
