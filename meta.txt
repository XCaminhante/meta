.syntax meta;
% MetaG metacompiler grammar
.initialize
  "static void meta_exp1(void);\n"
  "static void meta_exp3(void);\n"
  "char *grammar_name;\n";
% Token directives
%% C hex chars
hex = .any('0','9')|.any('a','f')|.any('A','F');
xchar = '\\x' .token hex hex .deftoken;
xcharp = '\\x' {"'"%} hex .putc hex .putc {"'"};
%% Text emitting
arg = '$' {'emit_token(1);'}
    | '%' {'emit_token(0);'}
    | ('lf'|'nl') {"emit_char('\\n');"}
    | 'cr' {"emit_char('\\r');"}
    | .id {'emit('$');'}
    | xchar {"emit_char('\\x" $ "');"};
output = '{' *(.string {'emit('$');'} | arg) '}'
       | '<' *(.string {%} | arg) '>';
%% Whitespace skipping mode for builtin tokens
space_control = '\\' {'ignore_whitespace=true;'}
              | '/' {'ignore_whitespace=false;'};
%% Special tokens
%%% Macro token and emitted code capture
user_token_delim = '.token' {'start_user_token();'}
                 | '.adjtoken' {'user_token_stack[utoken_stack_top-1]=pos-strlen(token);'}
                 | '.deftoken' {'end_user_token();'}
                 | '.mute' {'mute=true;'}
                 | '.unmute' {'mute=false;'}
                 | '.capture' {'if(capture)free(capture);capture=calloc(1,1);'}
                 | '.defcapture' {'capture_to_token();'};
%%% Byte-by-byte user defined tokens
user_token_arg = .number {$}
               | xcharp
               | .eq(39) .putc (.eq(92) {"\\\\"} | .eq(39) {"\\'"} | .any(32,126) .putc ) .eq(39) .putc;
user_tokens = '.any(' {'read_any_between('} user_token_arg ','{','} user_token_arg ')'{');'}
            | '.but(' {'read_any_but('} user_token_arg ','{','} user_token_arg ')'{');'}
            | '.eq(' {'read_char_eq('} user_token_arg ')'{');'}
            | '.neq(' {'read_char_neq('} user_token_arg ')'{');'}
            | '.putc' {'emit_char(source[pos-1]);'};
%%% Error handling
errors = '.error(' .string {'error('$');'} ')'
       | '.warn(' .string {'warning('$');'} ')'
       | '.expect(' .string {'expecting='$';unexpected=NULL;'} ')'
       | '.unexpect(' .string {'expecting=NULL;unexpected='$';'} ')'
       | '.noexpect' {'expecting=NULL;unexpected=NULL;'}
       | '.reason(' .string {'reason='$';'} ')'
       | '.noreason' {'reason=NULL;'}
       | '.failure' {'test_flag=false;exit_parse_rule();return;'}
       | '.success' {'test_flag=true;exit_parse_rule();return;'};
%%% Local rule variables
%%% You can define globals manually at the ".initialize" directive
user_vars = '.bind(' .id {'char *'$'=token;token=NULL;'} ')'
          | '.var(' .id .bind(name)
            ( ')' {'char *'name'=NULL;'}
            | '[' .number {'char 'name'['$'];'} ']' ')')
          | '.ltoa(' .id {'sprintf('$} ',' .id {',"%d",'$');'} ')'
          | '.set(' .id {'if('$')free('$');'$'=token;token=NULL;'} ')'
          | '.concat(' .id {'concatstr('$',token);free(token);token=NULL;'} ')'
          | '.clear(' .id {'if('$'){free('$');'$'=NULL;}'} ')'
          | '.emit(' .id {'emit('$');'} ')'
          | '.ifte(' .id {'if('$')emit('$');else emit('} ',' .string {$');'} ')';
%% Builtin tokens
%% ".space" directive is not affected by whitespace skipping mode
builtin_tokens = '.id' {'read_id();'}
               | '.number' {'read_number();'}
               | '.string' {'read_string();'}
               | '.space' {'skip_whitespace();'};
% Expressions
%% Optional, out-of-order rules
option_capture = '^' .capture exp3 .defcapture;
multiple_optionals =
  <'char *opts_stack[STACK_DEPTH];int last_opt=2;char idx[4];'>
  option_capture <'opts_stack[0]=token;token=NULL;'>
  option_capture <'opts_stack[1]=token;token=NULL;'>
  *( option_capture
     <'if(last_opt==STACK_DEPTH-1){'> .error('excess of optionals') <'}'
      'opts_stack[last_opt++]=token;token=NULL;'> )
  .ltoa(idx,last_opt)
  {'do{bool expr_results['idx'];'}
    <'for (int a=0; a<last_opt; a++){'> .ltoa(idx,a)
      {'do{'} <'emit(opts_stack[a]);'> {'}while(0);'
       'expr_results['idx']=test_flag;'}
    <'}'>
    <'for(int a=0;a<last_opt;a++){'> .ltoa(idx,a)
      {'if(!expr_results['idx'])do{'}
        <'emit(opts_stack[a]);free(opts_stack[a]);'>
      {'}while(0);'}
    <'}'>
  {'}while(0);test_flag=true;'}
  ;
%% Second level expressions (common directives level)
exp3 = .id {grammar_name'_'$'();'}
     | .string {'read_literal('$');'}
     | builtin_tokens
     | user_tokens
     | '(' exp1 ')'
     | '.e' {'test_flag=true;'}
     | '*' {'do{'} exp3 {'}while(test_flag);test_flag=true;'}
     | '!' {'do{long entry_pos=pos;'} exp3 {'pos=entry_pos;}while(0);test_flag^=true;'}
     | multiple_optionals;
dont_use_flag = user_token_delim
              | output
              | space_control
              | errors
              | user_vars;
exp2 = *dont_use_flag
       ( exp3 ( !(';'|'|'|')') {'if(test_flag){'}
         *( dont_use_flag | exp3 {'error_if_false();'} )
         {'}'} | .e )
       | .e);
exp1 = 'continue' .success
     | {'do{'}
       .expect('a sequence of expressions') exp2
       *('|' {'if(test_flag)break;'} .expect('a sequence of expressions') exp2)
       {'}while(0);'};
%% First level expressions
stat = '%' *.neq(10)
     | .expect('a grammar rule identifier') .id
         {'static void 'grammar_name'_'$'(void)'
          '{enter_parse_rule("'grammar_name'_'$'");'}
       .expect('an equal sign') '='
       .expect('a sequence of expressions') exp1
       .expect('a ; terminator') ';'
       {'exit_parse_rule();}\n'};
initialize = '%' *.neq(10) initialize
           | '.initialize'
             .expect('a sequence of code instructions (strings)') .string {%} *( .string {%} )
             .expect('a ; terminator') ';'
           | .e;
finalize = .expect('a compiler mode directive (.end,.multiple,.test,.finalize)')
           ( '.end'
             .expect('a grammar rule identifier') .id
             {'int main(int argc, char *argv[]){return first_into_second(argc,argv,'grammar_name'_'$');}\n'}
           | '.multiple'
             .expect('an file extension (string)') .string .bind(extension)
             .expect('a grammar rule identifier') .id
             {'int main(int argc, char *argv[]){ multiple_files(argc,argv,' extension ','grammar_name'_'$');return 0; }\n' }
           | '.test'
             .expect('a grammar rule identifier (optionally a maximum input size)') .id .bind(func_name)
             .var(max_input_size) (.number .set(max_input_size) | .e)
             {'int main (int argc, char *argv[]){return test('} .ifte(max_input_size,"4194304") {','grammar_name'_'func_name');}\n'}
           | '.finalize'
             .expect('a sequence of code instructions (strings)') .string <%> *(.string <%>) )
           .expect('a ; terminator') ';' ;
program = '.syntax'
            .expect('a grammar name') .space .id .set(grammar_name)
            .expect('a ; terminator')
            (.string {'#include "'%'/support.h"\n'} | .e {'#include "support.h"\n'}) ';'
          initialize
          *stat
          finalize;
.end program;
